//! `ship_template` defines `ShipTemplate`, its construction and modification.
//!
//! #Last Modified
//!
//! Author: Daniel Bechaz</br>
//! Date: 2017/11/06

use game::*;
use super::{ShipSize, Mass};
use super::ship_error::*;
use std::sync::{Arc, Once, ONCE_INIT};
use std::collections::HashMap;

pub type FuelUnit = UInt;
pub type HullPoint = UInt;
pub type ShieldPoint = UInt;
pub type DamagePoint = UInt;

#[derive(Debug, PartialEq, Eq, Copy, Clone)]
/// `ShipTemplate` is a representation of a type of Ship.
pub struct ShipTemplate {
    /// The size class of this Ship type.
    pub ship_size_class: ShipSize,
    /// The maximum units of fuel carried by this Ship type.
    fuel_capacity: FuelUnit,
    /// The number of units of fuel used by this Ship type in one period.
    fuel_use: FuelUnit,
    /// The maximum hull points (health points) of this Ship type.
    pub max_hull: HullPoint,
    /// The maximum shield points of this Ship type.
    shield_capacity: ShieldPoint,
    /// The number of shield points regenerated by this Ship type in one period.
    shield_recovery: ShieldPoint,
    /// The maximum units of Mass this Ship type can transport.
    pub cargo_capacity: Mass,
    /// The smallest size of Ship this Ship type can target.
    pub smallest_target: ShipSize,
    /// The ammount of damage dealt by this Ship type.
    pub attack_damage: DamagePoint
}

impl ShipTemplate {
    /// Returns a new `ShipTemplate` built from raw parts.
    ///
    /// #Params
    ///
    /// ship_size_class --- The size class of this Ship type.
    /// fuel_capacity --- The maximum units of fuel carried by this Ship type.
    /// fuel_use --- The number of units of fuel used by this Ship type in one period.
    /// defence_rating --- The percentage of attacks which this Ship type evades or absorbs without consequence.
    /// hull_points --- The maximum hull points (health points) of this Ship type.
    /// shield_points --- The maximum shield points of this Ship type.
    /// shield_recovery --- The number of shield points regenerated by this Ship type in one period.
    /// cargo_capacity --- The maximum units of Mass this Ship type can transport.
    pub unsafe fn from_parts(ship_size_class: ShipSize, fuel_capacity: UInt,
        fuel_use: UInt, max_hull: UInt, shield_capacity: UInt, shield_recovery: UInt,
        cargo_capacity: Mass, smallest_target: ShipSize, attack_damage: HullPoint) -> Self {
        Self {
            ship_size_class,
            fuel_capacity,
            fuel_use,
            max_hull,
            shield_capacity,
            shield_recovery,
            cargo_capacity,
            smallest_target,
            attack_damage
        }
    }
    /// Attempts to call `ShipTemplate::from_parts` if parameters pass checks.
    ///
    /// #Params
    ///
    /// Refer to `ShipTemplate::from_parts` for parameters.
    ///
    /// #Errors
    ///
    /// FuelError --- fuel_use > fuel_capacity
    /// ShieldError --- shield_recovery > shield_points
    pub fn new(ship_size_class: ShipSize, fuel_capacity: UInt, fuel_use: UInt,
        hull_points: UInt, shield_points: UInt, shield_recovery: UInt,
        cargo_capacity: Mass, smallest_target: ShipSize, attack_damage: HullPoint) -> Result<Self, ShipError> {
        //Check that fuel use is not greater than fuel capacity.
        if fuel_use > fuel_capacity {
            Err(FuelError)
        //Check that shield_recovery is not greater than shield capacity
        } else if shield_recovery > shield_points {
            Err(ShieldError)
        //All checks passed, parameters are valid.
        } else {
            Ok(
                unsafe {
                    ShipTemplate::from_parts(
                        ship_size_class,
                        fuel_capacity,
                        fuel_use,
                        hull_points,
                        shield_points,
                        shield_recovery,
                        cargo_capacity,
                        smallest_target,
                        attack_damage
                    )
                }
            )
        }
    }
    /// Returns the `fuel_capacity` of this `ShipTemplate`.
    pub fn get_fuel_capacity(&self) -> FuelUnit {
        self.fuel_capacity
    }
    /// Attempts to set the `fuel_capacity` of this `ShipTemplate`.
    ///
    /// #Params
    ///
    /// val --- The new value to set.
    ///
    /// #Errors
    ///
    /// FuelError --- val > fuel_capacity
    pub fn set_fuel_capacity(&mut self, val: FuelUnit) -> Result<(), ShipError> {
        if self.fuel_use > val {
            Err(FuelError)
        } else {
            self.fuel_capacity = val; Ok(())
        }
    }
    /// Returns the `fuel_use` of this `ShipTemplate`.
    pub fn get_fuel_use(&self) -> FuelUnit {
        self.fuel_use
    }
    /// Attempts to set the `fuel_use` of this `ShipTemplate`.
    ///
    /// #Params
    ///
    /// val --- The new value to set.
    ///
    /// #Errors
    ///
    /// FuelError --- fuel_use > val
    pub fn set_fuel_use(&mut self, val: FuelUnit) -> Result<(), ShipError> {
        if val > self.fuel_capacity {
            Err(FuelError)
        } else {
            self.fuel_use = val; Ok(())
        }
    }
    /// Returns the `shield_capacity` of this `ShipTemplate`.
    pub fn get_shield_capacity(&self) -> ShieldPoint {
        self.shield_capacity
    }
    /// Attempts to set the `shield_capacity` of this `ShipTemplate`.
    ///
    /// #Params
    ///
    /// val --- The new value to set.
    ///
    /// #Errors
    ///
    /// ShieldError --- shield_recovery > val
    pub fn set_shield_capacity(&mut self, val: ShieldPoint) -> Result<(), ShipError> {
        if self.shield_recovery > val {
            Err(ShieldError)
        } else {
            self.shield_capacity = val; Ok(())
        }
    }
    /// Returns the `shield_recovery` of this `ShipTemplate`.
    pub fn get_shield_recovery(&self) -> ShieldPoint {
        self.shield_recovery
    }
    /// Attempts to set the `shield_recovery` of this `ShipTemplate`.
    ///
    /// #Params
    ///
    /// val --- The new value to set.
    ///
    /// #Errors
    ///
    /// ShieldError --- val > shield_capacity
    pub fn set_shield_recovery(&mut self, val: ShieldPoint) -> Result<(), ShipError> {
        if val > self.shield_capacity {
            Err(ShieldError)
        } else {
            self.shield_recovery = val; Ok(())
        }
    }
    /// Returns true if this `ShipTemplate` can target the passed `ShipTemplate`.
    ///
    /// #Params
    ///
    /// target --- The `ShipTemplate` to attempt to target.
    pub fn can_target(&self, target: &Self) -> bool {
        self.smallest_target <= target.ship_size_class
    }
}

#[derive(Debug, Eq, Clone)]
/// A `ShipTemplate` with a name.
pub struct NamedTemplate(String, ShipTemplate);

impl PartialEq for NamedTemplate {
    fn eq(&self, other: &Self) -> bool {
        self.1 == other.1
    }
}

impl AsRef<ShipTemplate> for NamedTemplate {
    fn as_ref(&self) -> &ShipTemplate {
        &self.1
    }
}

static mut GAME_TEMPLATES: *mut HashMap<String, Arc<ShipTemplate>> = 0 as *mut HashMap<String, Arc<ShipTemplate>>;
static INIT_GAME_TEMPLATES: Once = ONCE_INIT;

#[cfg(feature="hardcoded")]
pub unsafe fn init_game_templates() {
    INIT_GAME_TEMPLATES.call_once(
        || {
            let mut templates = HashMap::with_capacity(2);
            macro_rules! hardcode_template {
                ($name:tt, $ship_size_class:expr, $fuel_capacity:expr, $fuel_use:expr,
                $hull_points:expr, $shield_points:expr, $shield_recovery:expr,
                $cargo_capacity:expr, $smallest_target:expr, $attack_damage:expr,
                $error:tt) => {
                    templates.insert(
                        String::from($name),
                        Arc::new(
                            ShipTemplate::new(
                                $ship_size_class,
                                $fuel_capacity,
                                $fuel_use,
                                $hull_points,
                                $shield_points,
                                $shield_recovery,
                                $cargo_capacity,
                                $smallest_target,
                                $attack_damage
                            ).expect($error)
                        )
                    )
                }
            }
            
            hardcode_template!("Light Fighter", 1, 10, 1, 100, 100, 1, 0, 1, 10, "Failed to create \"Light Fighter\".");
            GAME_TEMPLATES = Box::into_raw(Box::new(templates))
        }
    )
}
#[cfg(not(feature="hardcoded"))]
pub unsafe fn init_game_templates() {
    INIT_GAME_TEMPLATES.call_once(
        || GAME_TEMPLATES = Box::into_raw(Box::new(HashMap::new()))
    )
}
pub fn get_game_templates() -> &'static mut HashMap<String, Arc<ShipTemplate>> {
    unsafe {
        &mut *GAME_TEMPLATES
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_ship_template() {
        unsafe {
            let template = ShipTemplate::new(1, 10, 1, 100, 100, 1, 0, 1, 0);
            assert!(
                template.expect("`ShipTemplate::new` failed to create `ShipTemplate`."
                ) == ShipTemplate::from_parts(1, 10, 1, 100, 100, 1, 0, 1, 0),
                "`ShipTemplate::new` returned incorrect `ShipTemplate`."
            );
        }
        
        let template = ShipTemplate::new(1, 10, 1, 100, 0, 1, 0, 1, 0);
        assert!(
            template.expect_err("`ShipTemplate::new` failed to error on invalid `shield_recovery`."
            ) == ShieldError,
            "`ShipTemplate::new` returned incorrect `ShipError`."
        );
        
        let template = ShipTemplate::new(1, 0, 1, 100, 100, 1, 0, 1, 0);
        assert!(
            template.expect_err("`ShipTemplate::new` failed to error on invalid `fuel_use`."
            ) == FuelError,
            "`ShipTemplate::new` returned incorrect `ShipError`."
        );
    }
}
