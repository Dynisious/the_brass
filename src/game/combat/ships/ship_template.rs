//! `ship_template` defines `ShipTemplate`, its construction and modification.
//!
//! #Last Modified
//!
//! Author: Daniel Bechaz</br>
//! Date: 2017/11/09

use game::*;
use super::{ShipSize, Mass};
use super::ship_error::*;
use std::collections::LinkedList;
use std::sync::*;
use std::io::{self, Read};
use std::path::Path;
use std::rc::Rc;

pub type FuelUnit = UInt;
pub type HullPoint = UInt;
pub type ShieldPoint = UInt;
pub type DamagePoint = UInt;

#[derive(Debug, PartialEq, Eq, Copy, Clone, Deserialize)]
/// `ShipTemplate` is a representation of a type of Ship.
pub struct ShipTemplate {
    /// The size class of this Ship type.
    pub ship_size_class: ShipSize,
    /// The maximum units of fuel carried by this Ship type.
    fuel_capacity: FuelUnit,
    /// The number of units of fuel used by this Ship type in one period.
    fuel_use: FuelUnit,
    /// The maximum hull points (health points) of this Ship type.
    pub max_hull: HullPoint,
    /// The maximum shield points of this Ship type.
    shield_capacity: ShieldPoint,
    /// The number of shield points regenerated by this Ship type in one period.
    shield_recovery: ShieldPoint,
    /// The maximum units of Mass this Ship type can transport.
    pub cargo_capacity: Mass,
    /// The smallest size of Ship this Ship type can target.
    pub smallest_target: ShipSize,
    /// The ammount of damage dealt by this Ship type.
    pub attack_damage: DamagePoint
}

impl ShipTemplate {
    /// Returns a new `ShipTemplate` built from raw parts.
    ///
    /// #Params
    ///
    /// ship_size_class --- The size class of this Ship type.
    /// fuel_capacity --- The maximum units of fuel carried by this Ship type.
    /// fuel_use --- The number of units of fuel used by this Ship type in one period.
    /// defence_rating --- The percentage of attacks which this Ship type evades or absorbs without consequence.
    /// hull_points --- The maximum hull points (health points) of this Ship type.
    /// shield_points --- The maximum shield points of this Ship type.
    /// shield_recovery --- The number of shield points regenerated by this Ship type in one period.
    /// cargo_capacity --- The maximum units of Mass this Ship type can transport.
    pub unsafe fn from_parts(ship_size_class: ShipSize, fuel_capacity: UInt,
        fuel_use: UInt, max_hull: UInt, shield_capacity: UInt, shield_recovery: UInt,
        cargo_capacity: Mass, smallest_target: ShipSize, attack_damage: HullPoint) -> Self {
        Self {
            ship_size_class,
            fuel_capacity,
            fuel_use,
            max_hull,
            shield_capacity,
            shield_recovery,
            cargo_capacity,
            smallest_target,
            attack_damage
        }
    }
    /// Attempts to call `ShipTemplate::from_parts` if parameters pass checks.
    ///
    /// #Params
    ///
    /// Refer to `ShipTemplate::from_parts` for parameters.
    ///
    /// #Errors
    ///
    /// FuelError --- fuel_use > fuel_capacity
    /// ShieldError --- shield_recovery > shield_points
    pub fn new(ship_size_class: ShipSize, fuel_capacity: UInt, fuel_use: UInt,
        hull_points: UInt, shield_points: UInt, shield_recovery: UInt,
        cargo_capacity: Mass, smallest_target: ShipSize, attack_damage: HullPoint) -> Result<Self, ShipError> {
        //Check that fuel use is not greater than fuel capacity.
        if fuel_use > fuel_capacity {
            Err(FuelError)
        //Check that shield_recovery is not greater than shield capacity
        } else if shield_recovery > shield_points {
            Err(ShieldError)
        //All checks passed, parameters are valid.
        } else {
            Ok(
                unsafe {
                    ShipTemplate::from_parts(
                        ship_size_class,
                        fuel_capacity,
                        fuel_use,
                        hull_points,
                        shield_points,
                        shield_recovery,
                        cargo_capacity,
                        smallest_target,
                        attack_damage
                    )
                }
            )
        }
    }
    /// Returns the `fuel_capacity` of this `ShipTemplate`.
    pub fn get_fuel_capacity(&self) -> FuelUnit {
        self.fuel_capacity
    }
    /// Attempts to set the `fuel_capacity` of this `ShipTemplate`.
    ///
    /// #Params
    ///
    /// val --- The new value to set.
    ///
    /// #Errors
    ///
    /// FuelError --- val > fuel_capacity
    pub fn set_fuel_capacity(&mut self, val: FuelUnit) -> Result<(), ShipError> {
        if self.fuel_use > val {
            Err(FuelError)
        } else {
            self.fuel_capacity = val; Ok(())
        }
    }
    /// Returns the `fuel_use` of this `ShipTemplate`.
    pub fn get_fuel_use(&self) -> FuelUnit {
        self.fuel_use
    }
    /// Attempts to set the `fuel_use` of this `ShipTemplate`.
    ///
    /// #Params
    ///
    /// val --- The new value to set.
    ///
    /// #Errors
    ///
    /// FuelError --- fuel_use > val
    pub fn set_fuel_use(&mut self, val: FuelUnit) -> Result<(), ShipError> {
        if val > self.fuel_capacity {
            Err(FuelError)
        } else {
            self.fuel_use = val; Ok(())
        }
    }
    /// Returns the `shield_capacity` of this `ShipTemplate`.
    pub fn get_shield_capacity(&self) -> ShieldPoint {
        self.shield_capacity
    }
    /// Attempts to set the `shield_capacity` of this `ShipTemplate`.
    ///
    /// #Params
    ///
    /// val --- The new value to set.
    ///
    /// #Errors
    ///
    /// ShieldError --- shield_recovery > val
    pub fn set_shield_capacity(&mut self, val: ShieldPoint) -> Result<(), ShipError> {
        if self.shield_recovery > val {
            Err(ShieldError)
        } else {
            self.shield_capacity = val; Ok(())
        }
    }
    /// Returns the `shield_recovery` of this `ShipTemplate`.
    pub fn get_shield_recovery(&self) -> ShieldPoint {
        self.shield_recovery
    }
    /// Attempts to set the `shield_recovery` of this `ShipTemplate`.
    ///
    /// #Params
    ///
    /// val --- The new value to set.
    ///
    /// #Errors
    ///
    /// ShieldError --- val > shield_capacity
    pub fn set_shield_recovery(&mut self, val: ShieldPoint) -> Result<(), ShipError> {
        if val > self.shield_capacity {
            Err(ShieldError)
        } else {
            self.shield_recovery = val; Ok(())
        }
    }
    /// Returns true if this `ShipTemplate` can target the passed `ShipTemplate`.
    ///
    /// #Params
    ///
    /// target --- The `ShipTemplate` to attempt to target.
    pub fn can_target(&self, target: &Self) -> bool {
        self.smallest_target <= target.ship_size_class
    }
}

#[derive(Debug, Eq, Clone)]
/// A `ShipTemplate` with a name.
pub struct NamedTemplate(String, Rc<ShipTemplate>);

impl PartialEq for NamedTemplate {
    fn eq(&self, other: &Self) -> bool {
        self.1 == other.1
    }
}

impl AsRef<ShipTemplate> for NamedTemplate {
    fn as_ref(&self) -> &ShipTemplate {
        &self.1
    }
}

impl Drop for NamedTemplate {
    fn drop(&mut self) {
        //There should only be 1 strong reference from this named instance if this
        //template is being unloaded.
        if Rc::strong_count(&self.1) == 1 {
            eprintln!("\"{}\" has been unloaded.", self.0);
        } else {
            eprintln!("\"{}\" unloaded with live references!!!", self.0);
        }
    }
}

/// A `TemplateBuf` is a buffer of loaded `NamedTemplate`s.
/// The `TemplateBuf` is guarenteed to have space for at least `expected_load` templates
/// but will go over the expected load if needed.
pub struct TemplateBuf {
    /// The `NamedTemplate`s loaded on the heap.
    templates: LinkedList<Box<NamedTemplate>>,
    /// The minimum number of templates which can be loaded.
    pub expected_load: usize
}

static SHIPS_DIR: &str = "./res/ships/";

impl TemplateBuf {
    /// Builds a `TemplateBuf` from raw parts.
    ///
    /// #Params
    ///
    /// templates --- The collection of templates in this TemplateBuf.
    /// expected_load --- The minimum number of templates to keep loaded.
    pub fn new(templates: LinkedList<Box<NamedTemplate>>, expected_load: usize) -> Self {
        Self {
            templates,
            expected_load
        }
    }
    /// Creates an empty `TemplateBuf` with the passed `expected_load`.
    ///
    /// #Params
    ///
    /// expected_load --- The minimum number of templates to keep loaded.
    pub fn with_capacity(expected_load: usize) -> Self {
        Self::new(LinkedList::new(), expected_load)
    }
    /// Returns the number of loaded `ShipTemplate`s in this `TemplateBuf`.
    pub fn loaded(&self) -> usize {
        self.templates.len()
    }
    /// Unloads all templates which are over `expected_load` and have no live references.
    pub fn unload_overflow(&mut self) {
        //The number of templates over the `expected_load`.
        let mut to_unload = self.loaded() - self.expected_load;
        //The maximum number of iterations which can to be done.
        let mut iterated = self.loaded();
        
        //Iterate while theres more to unloaded and there are more iterations to do.
        while to_unload > 0 && iterated > 0 {
            //Get the next template from the list.
            let template = self.templates.pop_front().unwrap();
            
            //If this template should be unloaded there will only be one strong reference to it...
            if Rc::strong_count(&template.1) > 1 {
                //If there are more than one strong reference it should be kept...
                self.templates.push_back(template);
            } else {
                //Otherwise it should be unloaded...
                to_unload -= 1;
            }
            
            iterated -= 1;
        }
    }
    /// Attempts to unload the `ShipTemplate` identified with this name.
    /// Returns true if the template was unloaded.
    /// A template will not be unloaded if there are live references to it still.
    //
    /// #Params
    ///
    /// name --- The name of the `NamedTemplate` to be unloaded.
    pub fn unload(&mut self, name: &String) -> bool {
        //Stop iteration once all the templates have been iterated.
        for _ in 0..self.loaded() {
            //Gets the next template.
            let template = self.templates.pop_front().unwrap();
            
            //Check if it is the correct template...
            if &template.0 == name {
                //Check that there are no live references to this template...
                if Rc::strong_count(&template.1) > 1 {
                    //Retain it if there are live references and return.
                    self.templates.push_back(template);
                    return false;
                //If there are no live references drop it and return.
                } else {
                    return true;
                }
            //If its not the correct template, retain it.
            } else {
                self.templates.push_back(template);
            }
        }
        
        return false;
    }
    /// Attempts to get the `ShipTemplate` of the given name.
    /// If the template is not in the buffer it will attempt to be loaded.
    ///
    /// #Params
    ///
    /// name --- The name of the `ShipTemplate` to get.
    pub fn get(&mut self, name: &String) -> Option<Rc<ShipTemplate>> {
        //Search the loaded templates for the correct template.
        let res = self.templates.iter()
        .find(|template| &template.0 == name)
        .map(|template| template.1.clone());
        
        //If the template was not found, attempt to load and return it.
        res.or_else(|| {
            //Build a path to the `.ship` file.
            let mut file_path = String::from(SHIPS_DIR);
            file_path.push_str(name);
            file_path.push_str(".ship");
            
            //Attempt to load the template.
            match load_template(file_path.as_ref()) {
                //If the template was loaded successfully.
                Ok(template) => {
                    //Store it on the heap and keep a reference in the buffer.
                    self.templates.push_front(
                        Box::new(NamedTemplate(name.clone(), Rc::new(template)))
                    );
                    eprintln!("\"{}\" has been loaded.", name);
                    //Return the new template.
                    Some(self.templates.front().unwrap().1.clone())
                },
                //There was an error while loading the template.
                Err(e) => { eprintln!("\"{}\" could not be loaded:\n    {:?}", name, e); None }
            }
        })
    }
}

/// Attempt to load a `ShipTemplate` from a `.ship` file.
///
/// #Params
///
/// file_path --- The path to the `.ship` file to load. 
fn load_template(file_path: &Path) -> Result<ShipTemplate, Result<io::Error, ::toml::de::Error>> {
    eprintln!("Loading {:?}...", file_path);
    //Open the file...
    ::std::fs::File::open(file_path)
    .and_then(|mut file| {
        //Create a buffer for the content.
        let mut content = String::new();
        
        //Read in the content and return it.
        file.read_to_string(&mut content)
        .map(|_| content)
    //Map error values to the result type.
    }).map_err(|e| Ok(e)
    //If the reading succeeded, attempt to enterperate the `.ship` file...
    ).and_then(|content| ::toml::from_str(content.as_str()
        //Map error values to the result type.
        ).map_err(|e| Err(e))
    )
}


static mut GAME_TEMPLATES: *mut Mutex<TemplateBuf> = 0 as *mut Mutex<TemplateBuf>;
static INIT_GAME_TEMPLATES: Once = ONCE_INIT;
pub unsafe fn init_game_templates() {
    INIT_GAME_TEMPLATES.call_once(|| {
        const DEFAULT_LOAD: usize = 10;
        
        GAME_TEMPLATES = Box::into_raw(Box::new(Mutex::new(TemplateBuf::with_capacity(DEFAULT_LOAD))));
    })
}
pub fn get_game_templates() -> MutexGuard<'static, TemplateBuf> {
    unsafe {
        (*GAME_TEMPLATES).lock().expect("Ship Templates Mutex Poisoned!!!")
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_ship_template() {
        unsafe {
            let template = ShipTemplate::new(1, 10, 1, 100, 100, 1, 0, 1, 0);
            assert!(
                template.expect("`ShipTemplate::new` failed to create `ShipTemplate`."
                ) == ShipTemplate::from_parts(1, 10, 1, 100, 100, 1, 0, 1, 0),
                "`ShipTemplate::new` returned incorrect `ShipTemplate`."
            );
        }
        
        let template = ShipTemplate::new(1, 10, 1, 100, 0, 1, 0, 1, 0);
        assert!(
            template.expect_err("`ShipTemplate::new` failed to error on invalid `shield_recovery`."
            ) == ShieldError,
            "`ShipTemplate::new` returned incorrect `ShipError`."
        );
        
        let template = ShipTemplate::new(1, 0, 1, 100, 100, 1, 0, 1, 0);
        assert!(
            template.expect_err("`ShipTemplate::new` failed to error on invalid `fuel_use`."
            ) == FuelError,
            "`ShipTemplate::new` returned incorrect `ShipError`."
        );
    }
}
